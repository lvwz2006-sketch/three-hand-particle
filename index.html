<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>å“ˆåˆ©Â·æ³¢ç‰¹ä¸æ€ªå¥‡ç‰©è¯­ï¼šæ–½æ³•ç²’å­</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: radial-gradient(circle at center, #0a0a0d, #000); 
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      color: #fff;
    }

    body::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 100 100"><filter id="n" x="0" y="0" width="100%" height="100%"><feTurbulence type="fractalNoise" baseFrequency="0.005" numOctaves="1" result="f"></feTurbulence><feColorMatrix type="matrix" values="0 0 0 0 0, 0 0 0 0 0, 0 0 0 0 0, 0 0 0 0.1 0"></feColorMatrix></filter><rect width="100%" height="100%" filter="url(%23n)"></rect></svg>');
      opacity: 0.1;
      animation: noise-anim 10s infinite alternate linear;
      pointer-events: none;
    }

    @keyframes noise-anim {
      0% { transform: translate(0, 0); }
      100% { transform: translate(100%, 100%); }
    }

    #ui {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 10;
      background: rgba(20, 25, 40, 0.7);
      backdrop-filter: blur(10px);
      border-radius: 14px;
      padding: 12px 14px;
      display: flex;
      gap: 10px;
      align-items: center;
    }

    select, input, button {
      background: #1e2438;
      border: 1px solid #3a3f5a;
      color: white;
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 13px;
    }

    #fullscreenBtn {
      position: fixed;
      left: 20px;
      top: 90px;
      z-index: 10;
    }

    #tip {
      position: fixed;
      bottom: 20px;
      width: 100%;
      text-align: center;
      font-size: 13px;
      opacity: 0.7;
    }
    
    #tip span {
        display: block;
        margin-top: 5px;
        font-size: 11px;
        color: #aaa;
    }

    canvas {
      display: block;
    }

    #startBtn {
      position: fixed;
      inset: 0;
      margin: auto;
      width: 170px;
      height: 54px;
      font-size: 17px;
      border-radius: 14px;
      border: none;
      background: linear-gradient(135deg,#6ea8ff,#4760ff);
      color: white;
      z-index: 9999;
    }

    video {
      display: none;
    }

    #spellText {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 4em;
      font-weight: bold;
      color: #ffd700;
      text-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 0 10px rgba(255, 215, 0, 0.5);
      opacity: 0;
      transition: opacity 0.5s ease-out, transform 0.5s ease-out;
      pointer-events: none;
      z-index: 11;
      white-space: nowrap;
    }
    .spell-active {
        opacity: 1 !important;
        transform: translate(-50%, -50%) scale(1.1);
    }
  </style>
</head>

<body>

<button id="startBtn">å¼€å§‹ä½“éªŒ</button>

<div id="ui">
  <select id="shapeSelect">
    <option value="default">é»˜è®¤æ˜Ÿäº‘</option>
    <option value="heart">çˆ±å¿ƒ</option>
    <option value="flower">èŠ±æœµ</option>
    <option value="star">æ˜Ÿæ˜Ÿ</option>
    <option value="firework">çƒŸèŠ±</option>
    <option value="deathlyHallows">æ­»äº¡åœ£å™¨</option>
    <option value="lightningScar">é—ªç”µç–¤ç—•</option>
  </select>

  <input type="color" id="colorPicker" value="#FFD700">
</div>

<button id="fullscreenBtn">å…¨å±</button>

<div id="tip">
    åŒæ‰‹æ‹‡æŒ‡ä¸é£ŸæŒ‡ï¼šé è¿‘ â†’ æ”¶ç¼© ï½œ åˆ†å¼€ â†’ æ‰©æ•£
    <span>åŒæ‰‹æŒå¿ƒï¼šé è¿‘ â†’ æ–¥åŠ› (æ€ªå¥‡ç‰©è¯­èƒ½é‡å†²å‡») ï½œ åˆ†å¼€ â†’ å¼•åŠ› (æ€ªå¥‡ç‰©è¯­èƒ½é‡åœº)</span>
    <span>å•æ‰‹å¼ å¼€å¹¶ç§»åŠ¨ï¼šæ–½å±•å’’è¯­ (å“ˆåˆ©Â·æ³¢ç‰¹é­”æ³•ç«èŠ±)</span>
</div>

<div id="spellText"></div> 
<video id="video" autoplay playsinline muted></video>

<audio id="spellSound" src="spell.mp3" preload="auto"></audio> 

<script src="./three.min.js"></script>
<script src="./hands.min.js"></script>

<script>
  let scene = new THREE.Scene();
  let camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 1000);
  let renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });

  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  camera.position.z = 80;

  let particles, geometry, material;
  let particlePositions;
  let targetScale = 1;
  let particleColor = new THREE.Color(document.getElementById("colorPicker").value);
  let originalParticleColor = particleColor.clone(); 

  let handCenters = []; 
  let forceFactor = 0.05; 
  let repulsionThreshold = 30; 

  let spellParticles = [];
  let spellParticleMaterial;
  let lastHandPosition = new THREE.Vector3(); 
  let isCastingSpell = false;
  let spellCooldown = 0;
  const SPELL_COOLDOWN_TIME = 120; 

  const spells = [
    "Expelliarmus! (é™¤ä½ æ­¦å™¨ï¼)",
    "Lumos! (è§å…‰é—ªçƒï¼)",
    "Alohomora! (é˜¿æ‹‰éœæ´å¼€ï¼)",
    "Wingardium Leviosa! (ç¾½åŠ è¿ªå§† å‹’ç»´å¥¥è¨ï¼)",
    "Expecto Patronum! (å‘¼ç¥æŠ¤å«ï¼)",
    "Avada Kedavra! (é˜¿ç“¦è¾¾ç´¢å‘½ï¼ - ä»…ä¾›æ•ˆæœå±•ç¤ºï¼Œè¯·å‹¿è¯¯ç”¨)"
  ];
  const spellSound = document.getElementById('spellSound');


  // ç²’å­å½¢çŠ¶ç”Ÿæˆå‡½æ•° (ä¸ºç®€æ´çœç•¥ï¼Œå†…å®¹ä¸æ‚¨ä¸Šæ¬¡æä¾›çš„ä»£ç ä¸€è‡´)
  function generateShapePositions(shapeName, count, scale = 1) {
    let positions = [];
    switch (shapeName) {
      case 'heart':
        for (let i = 0; i < count; i++) {
          let t = Math.random() * 2 * Math.PI;
          let x = 16 * Math.pow(Math.sin(t), 3) * scale;
          let y = (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t)) * scale;
          positions.push(x, y, (Math.random() - 0.5) * 5);
        }
        break;
      case 'flower':
        for (let i = 0; i < count; i++) {
          let t = Math.random() * 2 * Math.PI;
          let r = 20 * (1 + 0.8 * Math.sin(6 * t)) * scale;
          let x = r * Math.cos(t);
          let y = r * Math.sin(t);
          positions.push(x, y, (Math.random() - 0.5) * 5);
        }
        break;
      case 'star':
        for (let i = 0; i < count; i++) {
          let t = Math.random() * 2 * Math.PI;
          let r = (20 + Math.random() * 10) * scale;
          let x = r * Math.cos(t);
          let y = r * Math.sin(t);
          positions.push(x, y, (Math.random() - 0.5) * 5);
        }
        break;
      case 'firework':
        for (let i = 0; i < count; i++) {
          let x = (Math.random() - 0.5) * 60;
          let y = (Math.random() - 0.5) * 60;
          let z = (Math.random() - 0.5) * 60;
          positions.push(x, y, z);
        }
        break;
      case 'deathlyHallows':
        for (let i = 0; i < count; i++) {
          let x, y, z;
          if (Math.random() < 0.3) {
            let a = Math.random();
            let b = Math.random();
            if (a + b > 1) { a = 1 - a; b = 1 - b; }
            x = (a * (-20) + b * 20 + (1 - a - b) * 0) * scale;
            y = (a * (-15) + b * (-15) + (1 - a - b) * 15) * scale;
          } else if (Math.random() < 0.6) {
            let angle = Math.random() * 2 * Math.PI;
            x = Math.cos(angle) * 8 * scale;
            y = Math.sin(angle) * 8 * scale - 5 * scale;
          } else {
            x = 0;
            y = (Math.random() - 0.5) * 20 * scale;
          }
          z = (Math.random() - 0.5) * 2 * scale;
          positions.push(x, y, z);
        }
        break;
      case 'lightningScar':
        for (let i = 0; i < count; i++) {
          let p = Math.random();
          let x, y;
          if (p < 0.33) {
            x = THREE.MathUtils.lerp(-10, 0, p * 3) * scale;
            y = THREE.MathUtils.lerp(0, 10, p * 3) * scale;
          } else if (p < 0.66) {
            p = (p - 0.33) * 3;
            x = THREE.MathUtils.lerp(0, 10, p) * scale;
            y = THREE.MathUtils.lerp(10, -10, p) * scale;
          } else {
            p = (p - 0.66) * 3;
            x = THREE.MathUtils.lerp(10, 20, p) * scale;
            y = THREE.MathUtils.lerp(-10, 0, p) * scale;
          }
          positions.push(x, y, (Math.random() - 0.5) * 2 * scale);
        }
        break;
      case 'default':
      default:
        for (let i = 0; i < count; i++) {
          positions.push(
            (Math.random() - 0.5) * 50,
            (Math.random() - 0.5) * 50,
            (Math.random() - 0.5) * 50
          );
        }
        break;
    }
    return positions;
  }
  
  function createParticles(shapeName, color) {
    if (particles) scene.remove(particles);

    geometry = new THREE.BufferGeometry();
    const count = 2000;
    particlePositions = new Float32Array(generateShapePositions(shapeName, count, 0.8));
    let currentPositions = new Float32Array(particlePositions);

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(currentPositions, 3));
    
    material = new THREE.PointsMaterial({
      color: color,
      size: 0.8,
      transparent: true,
      opacity: 0.9,
      blending: THREE.AdditiveBlending
    });

    particles = new THREE.Points(geometry, material);
    scene.add(particles);
    particleColor.set(color); 
    originalParticleColor.set(color); 
  }

  createParticles(document.getElementById("shapeSelect").value, document.getElementById("colorPicker").value);

  spellParticleMaterial = new THREE.PointsMaterial({
      color: 0xFFF0B0, 
      size: 1.5,
      transparent: true,
      opacity: 0.8,
      blending: THREE.AdditiveBlending,
      depthWrite: false 
  });

  function createSpellParticles(position) {
      const spellGeometry = new THREE.BufferGeometry();
      const spellPositions = [];
      const spellLifetimes = [];
      const numSpellParticles = 50;

      for (let i = 0; i < numSpellParticles; i++) {
          spellPositions.push(
              position.x + (Math.random() - 0.5) * 5,
              position.y + (Math.random() - 0.5) * 5,
              position.z + (Math.random() - 0.5) * 5
          );
          spellLifetimes.push(Math.random() * 60 + 30);
      }
      spellGeometry.setAttribute('position', new THREE.Float32BufferAttribute(spellPositions, 3));
      spellGeometry.setAttribute('lifetime', new THREE.Float32BufferAttribute(spellLifetimes, 1)); 

      const newSpellParticles = new THREE.Points(spellGeometry, spellParticleMaterial.clone());
      newSpellParticles.name = 'spellEffect'; 
      scene.add(newSpellParticles);
      spellParticles.push(newSpellParticles);
  }


  function animate() {
    requestAnimationFrame(animate);

    if (spellCooldown > 0) {
        spellCooldown--;
    }

    if (particles && particlePositions && handCenters.length > 0) {
      let currentPositions = geometry.attributes.position.array;
      let tempVector = new THREE.Vector3();

      for (let i = 0; i < particlePositions.length; i += 3) {
        tempVector.set(currentPositions[i], currentPositions[i+1], currentPositions[i+2]);
        
        handCenters.forEach(handCenter => {
          let dx = tempVector.x - handCenter.x;
          let dy = tempVector.y - handCenter.y;
          let dz = tempVector.z - handCenter.z;
          let distSq = dx*dx + dy*dy + dz*dz;
          let dist = Math.sqrt(distSq);

          if (dist > 0) {
            dx /= dist; dy /= dist; dz /= dist;
          } else { 
            dx = Math.random() - 0.5; dy = Math.random() - 0.5; dz = Math.random() - 0.5;
            let len = Math.sqrt(dx*dx+dy*dy+dz*dz);
            dx /= len; dy /= len; dz /= len;
          }
          
          let forceStrength = 0;
          if (handCenters.length > 1) { 
              if (handCenter.distToOtherHand < repulsionThreshold) { 
                  forceStrength = forceFactor * 10 / (distSq + 1); 
              } else { 
                  forceStrength = -forceFactor * 5 / (distSq + 1); 
              }
          } else { 
             forceStrength = -forceFactor * 0.5 / (distSq + 1); 
          }
          
          currentPositions[i] += dx * forceStrength;
          currentPositions[i+1] += dy * forceStrength;
          currentPositions[i+2] += dz * forceStrength;
        });

        currentPositions[i] += (particlePositions[i] - currentPositions[i]) * 0.01;
        currentPositions[i+1] += (particlePositions[i+1] - currentPositions[i+1]) * 0.01;
        currentPositions[i+2] += (particlePositions[i+2] - currentPositions[i+2]) * 0.01;
      }
      geometry.attributes.position.needsUpdate = true;
    }


    for (let i = spellParticles.length - 1; i >= 0; i--) {
        const sp = spellParticles[i];
        const lifetimes = sp.geometry.attributes.lifetime.array;
        const positions = sp.geometry.attributes.position.array;
        const opacities = sp.material.opacity;

        let allDead = true;
        for (let j = 0; j < lifetimes.length; j++) {
            lifetimes[j]--;
            if (lifetimes[j] > 0) {
                allDead = false;
                positions[j*3+1] += 0.2; 
                positions[j*3] += (Math.random() - 0.5) * 0.5; 
                positions[j*3+2] += (Math.random() - 0.5) * 0.5; 
            } else {
                positions[j*3] = positions[j*3+1] = positions[j*3+2] = 10000; 
            }
        }
        sp.geometry.attributes.position.needsUpdate = true;
        
        if (allDead) {
            scene.remove(sp);
            spellParticles.splice(i, 1);
        } else {
            sp.material.opacity = Math.max(0, opacities * 0.95 - 0.01); 
        }
    }


    if (particles) {
      particles.rotation.y += 0.002;
      particles.scale.setScalar(targetScale);

      if (handCenters.length === 2) {
          let distBetweenHands = handCenters[0].distanceTo(handCenters[1]);
          if (distBetweenHands < repulsionThreshold * 2) { 
              let mixFactor = 1 - (distBetweenHands / (repulsionThreshold * 2));
              material.color.lerpColors(originalParticleColor, new THREE.Color(0xAA0000), mixFactor * 0.7);
              material.opacity = 0.8 + Math.sin(performance.now() * 0.1) * 0.15;
          } else {
              material.color.copy(originalParticleColor);
              material.opacity = 0.9;
          }
      } else {
          material.color.copy(originalParticleColor);
          material.opacity = 0.9;
      }
    }
    renderer.render(scene, camera);
  }

  animate();

  window.onresize = () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  };

  document.getElementById("fullscreenBtn").onclick = () => {
    if (!document.fullscreenElement) {
      document.body.requestFullscreen();
    } else {
      document.exitFullscreen();
    }
  };

  document.getElementById("colorPicker").oninput = e => {
    material.color.set(e.target.value);
    originalParticleColor.set(e.target.value);
  };
  
  document.getElementById("shapeSelect").onchange = e => {
    createParticles(e.target.value, document.getElementById("colorPicker").value);
  };

  // ===== MediaPipe æ‰‹åŠ¿è¯†åˆ« - æ ¸å¿ƒä¿®æ”¹ =====
  const video = document.getElementById('video');
  const spellTextElement = document.getElementById('spellText');

  const hands = new Hands({
    maxNumHands: 2,
    minDetectionConfidence: 0.6,
    minTrackingConfidence: 0.6,
    // ğŸš€ å…³é”®ä¿®æ”¹ï¼šlocateFile å¿…é¡»æŒ‡å‘æœ¬åœ°æ–‡ä»¶è·¯å¾„ï¼
    locateFile: (file) => `./${file}` 
  });

  hands.onResults(results => {
    handCenters = []; 
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
      let p1 = results.multiHandLandmarks[0][4]; 
      let p2 = results.multiHandLandmarks[0][8]; 
      let dx = p1.x - p2.x;
      let dy = p1.y - p2.y;
      let dist = Math.sqrt(dx * dx + dy * dy);
      targetScale = THREE.MathUtils.clamp(dist * 5, 0.3, 3);

      results.multiHandLandmarks.forEach((handLandmarks, index) => {
        let middleFingerBase = handLandmarks[9]; 
        let x = (middleFingerBase.x - 0.5) * window.innerWidth / 10;
        let y = -(middleFingerBase.y - 0.5) * window.innerHeight / 10;
        let z = (middleFingerBase.z * 100 - 50) * 0.5; 
        let handCenter3D = new THREE.Vector3(x, y, z);

        if (results.multiHandLandmarks.length > 1) {
            let otherHandIndex = index === 0 ? 1 : 0;
            let otherHandBase = results.multiHandLandmarks[otherHandIndex][9];
            let otherHandX = (otherHandBase.x - 0.5) * window.innerWidth / 10;
            let otherHandY = -(otherHandBase.y - 0.5) * window.innerHeight / 10;
            let otherHandZ = (otherHandBase.z * 100 - 50) * 0.5;
            let otherHandCenter3D = new THREE.Vector3(otherHandX, otherHandY, otherHandZ);
            handCenter3D.distToOtherHand = handCenter3D.distanceTo(otherHandCenter3D);
        }
        
        handCenters.push(handCenter3D);

        const indexTip = handLandmarks[8];
        const middleTip = handLandmarks[12];
        const ringTip = handLandmarks[16];
        const pinkyTip = handLandmarks[20];
        const wristPoint = handLandmarks[0];

        // ç®€åŒ–åçš„å¼ å¼€æ‰‹æŒæ£€æµ‹
        const isHandOpen = 
            indexTip.y < wristPoint.y * 0.8 &&
            middleTip.y < wristPoint.y * 0.8 &&
            ringTip.y < wristPoint.y * 0.8 &&
            pinkyTip.y < wristPoint.y * 0.8 &&
            dist > 0.1; 

        let currentHandPosition = new THREE.Vector3(x, y, z);
        let handSpeed = currentHandPosition.distanceTo(lastHandPosition);
        lastHandPosition.copy(currentHandPosition);

        if (isHandOpen && handSpeed > 3 && spellCooldown <= 0) { 
            isCastingSpell = true;
            spellCooldown = SPELL_COOLDOWN_TIME; 
            castSpell(handCenter3D);
        } else {
            isCastingSpell = false;
        }

      });
    }
  });

  function castSpell(handPosition) {
    if (spellSound) {
        spellSound.currentTime = 0; 
        spellSound.play().catch(e => console.log("Spell sound failed to play:", e)); 
    }
    createSpellParticles(handPosition); 

    const randomSpell = spells[Math.floor(Math.random() * spells.length)];
    spellTextElement.textContent = randomSpell;
    spellTextElement.classList.add('spell-active');
    setTimeout(() => {
        spellTextElement.classList.remove('spell-active');
    }, 1500); 
  }


  async function sendFrameToHands() {
    if (video.readyState >= 2) { 
      await hands.send({ image: video });
    }
    requestAnimationFrame(sendFrameToHands);
  }

  // ğŸš€ å…¼å®¹æ€§ä¿®å¤åçš„å¯åŠ¨é€»è¾‘
  document.getElementById("startBtn").onclick = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          // ç§»é™¤ facingModeï¼Œè®©æµè§ˆå™¨è‡ªåŠ¨é€‰æ‹©æ‘„åƒå¤´ï¼Œæé«˜å…¼å®¹æ€§
          width: 640,
          height: 480
        }
      });
      
      video.srcObject = stream;
      
      video.onloadeddata = () => {
          video.play();
          document.getElementById("startBtn").style.display = "none";
          sendFrameToHands(); 
      };
      
    } catch (e) {
      alert("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼è¯·æ£€æŸ¥ç³»ç»Ÿæƒé™æˆ–é‡å¯æµè§ˆå™¨ã€‚\né”™è¯¯ä¿¡æ¯ï¼š" + e.message + 
            "\næç¤ºï¼šç¡®ä¿æ‘„åƒå¤´æœªè¢«å…¶ä»–åº”ç”¨å ç”¨ï¼Œä¸”æµè§ˆå™¨æ‹¥æœ‰æ‘„åƒå¤´æƒé™ã€‚");
    }
  };
</script>

</body>
</html>
