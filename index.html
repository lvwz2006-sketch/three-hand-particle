<!doctype html>
<html lang="zh">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Three.js 实时手势控制粒子系统</title>
<style>
  html,body { height:100%; margin:0; font-family: Inter, system-ui, Arial; background:#0b0f14; color:#e6eef8; }
  #container { position:fixed; inset:0; overflow:hidden; }
  canvas { display:block; }
  #uiTop {
    position: absolute; left: 16px; top: 16px; z-index: 20; display:flex; gap:8px; align-items:center;
  }
  .btn {
    background: rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.06);
    color: #e6eef8; padding:8px 12px; border-radius:8px; cursor:pointer; backdrop-filter: blur(6px);
    font-size:13px;
  }
  .btn:hover { background: rgba(255,255,255,0.09) }
  #videoEl { position: absolute; right:16px; top:16px; width:180px; max-width:30%; border-radius:8px; z-index:10; opacity:0.18; pointer-events:none; }
  #footer {
    position: absolute; left:16px; bottom:16px; z-index:20; font-size:13px; color:#9fb0d6; opacity:0.9;
  }
  .small { font-size:12px; color:#9fb0d6; }
  #uploader { margin-left:8px; }
</style>
</head>
<body>
<div id="container"></div>

<!-- Camera preview (transparent, for debug) -->
<video id="videoEl" autoplay playsinline></video>

<div id="uiTop">
  <button id="fsBtn" class="btn">全屏</button>
  <input id="colorPicker" type="color" value="#ff66a5" title="粒子颜色" />
  <label class="btn" style="display:inline-flex; gap:8px; align-items:center;">
    选择模型
    <select id="modelSelect" style="background:transparent;border:none;color:inherit">
      <option value="heart">爱心</option>
      <option value="flower">花朵</option>
      <option value="star">五角星</option>
      <option value="buddha">佛像 (上传点云/模型)</option>
      <option value="fireworks">烟花</option>
    </select>
  </label>
  <input id="uploader" type="file" accept=".gltf,.glb,.obj,.json,.ply" title="上传点云/模型（用于佛像）" />
</div>

<div id="footer">双手拇指与食指张合控制粒子：<span class="small">靠近→收缩，分开→扩散</span></div>

<!-- Three.js -->
<script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>
<!-- OrbitControls (optional for debugging) -->
<script src="https://unpkg.com/three@0.155.0/examples/js/controls/OrbitControls.js"></script>
<!-- GLTFLoader for optional model upload -->
<script src="https://unpkg.com/three@0.155.0/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://unpkg.com/three@0.155.0/examples/js/loaders/PLYLoader.js"></script>

<!-- lil-gui for UI (optional but nice) -->
<script src="https://cdn.jsdelivr.net/npm/lil-gui@0.18/dist/lil-gui.min.js"></script>

<!-- MediaPipe Hands -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
(async function(){
  // ---------- 基本设置 ----------
  const container = document.getElementById('container');
  const videoEl = document.getElementById('videoEl');
  const colorPicker = document.getElementById('colorPicker');
  const modelSelect = document.getElementById('modelSelect');
  const fsBtn = document.getElementById('fsBtn');
  const uploader = document.getElementById('uploader');

  let width = container.clientWidth, height = container.clientHeight;
  const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(width, height);
  container.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x071017);

  const camera = new THREE.PerspectiveCamera(50, width/height, 0.1, 1000);
  camera.position.set(0, 0, 120);

  // subtle ambient
  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const dir = new THREE.DirectionalLight(0xffffff, 0.6);
  dir.position.set(5,10,7);
  scene.add(dir);

  // orbit controls for debug (comment out in production)
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;
  controls.enablePan = false;
  controls.minDistance = 30;
  controls.maxDistance = 300;

  // ---------- 粒子系统 ----------
  const MAX_PARTICLES = 12000; // 总数上限
  let particleGeometry = new THREE.BufferGeometry();
  const positions = new Float32Array(MAX_PARTICLES * 3);
  const initSizes = new Float32Array(MAX_PARTICLES);
  const offsets = new Float32Array(MAX_PARTICLES * 3); // 用于动画
  const colors = new Float32Array(MAX_PARTICLES * 3);

  // 默认填 0
  for(let i=0;i<MAX_PARTICLES;i++){
    positions[i*3+0]=0; positions[i*3+1]=0; positions[i*3+2]=0;
    initSizes[i] = 1.0;
    offsets[i*3+0]=Math.random()*2-1; offsets[i*3+1]=Math.random()*2-1; offsets[i*3+2]=Math.random()*2-1;
    colors[i*3+0]=1; colors[i*3+1]=0.4; colors[i*3+2]=0.65;
  }

  particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions,3).setUsage(THREE.DynamicDrawUsage));
  particleGeometry.setAttribute('aSize', new THREE.BufferAttribute(initSizes,1).setUsage(THREE.DynamicDrawUsage));
  particleGeometry.setAttribute('aOffset', new THREE.BufferAttribute(offsets,3));
  particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors,3));

  // ShaderMaterial：点会有发光感
  const particleMat = new THREE.ShaderMaterial({
    transparent: true,
    depthWrite: false,
    vertexColors: true,
    blending: THREE.AdditiveBlending,
    uniforms: {
      uTime: { value: 0 },
      uScale: { value: 1.0 },
      uSpread: { value: 1.0 },
      uPointSize: { value: 8.0 },
      uColor: { value: new THREE.Color(colorPicker.value) },
      uPixelRatio: { value: window.devicePixelRatio }
    },
    vertexShader: `
      attribute float aSize;
      attribute vec3 aOffset;
      varying vec3 vColor;
      uniform float uTime;
      uniform float uScale;
      uniform float uSpread;
      void main(){
        vColor = color;
        vec3 pos = position + aOffset * uSpread;
        pos *= uScale;
        // subtle floating
        pos.y += sin((aOffset.x + uTime * 0.8) * 0.8) * 0.6;
        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
        gl_PointSize = (uPointSize * aSize) * (uPixelRatio) * (150.0 / -mvPosition.z);
        gl_Position = projectionMatrix * mvPosition;
      }
    `,
    fragmentShader: `
      varying vec3 vColor;
      uniform vec3 uColor;
      void main(){
        // soft circular point
        vec2 c = gl_PointCoord * 2.0 - 1.0;
        float r = dot(c, c);
        float alpha = smoothstep(1.0, 0.2, r);
        vec3 col = mix(vColor, uColor, 0.18);
        gl_FragColor = vec4(col, alpha);
      }
    `
  });

  const points = new THREE.Points(particleGeometry, particleMat);
  scene.add(points);

  // ---------- 生成不同形状点分布函数 ----------
  function setPointCloudFromArray(arr) {
    // arr: array of {x,y,z} centered around origin and scaled reasonably
    const n = Math.min(arr.length, MAX_PARTICLES);
    const posAttr = particleGeometry.getAttribute('position');
    const offAttr = particleGeometry.getAttribute('aOffset');
    for(let i=0;i<MAX_PARTICLES;i++){
      const base = i % n;
      if(i < n){
        posAttr.array[i*3+0] = arr[base].x;
        posAttr.array[i*3+1] = arr[base].y;
        posAttr.array[i*3+2] = arr[base].z;
        offAttr.array[i*3+0] = (Math.random()*2-1) * 0.02;
        offAttr.array[i*3+1] = (Math.random()*2-1) * 0.02;
        offAttr.array[i*3+2] = (Math.random()*2-1) * 0.02;
      } else {
        // place off-screen / near origin
        posAttr.array[i*3+0] = arr[base].x + (Math.random()-0.5)*0.1;
        posAttr.array[i*3+1] = arr[base].y + (Math.random()-0.5)*0.1;
        posAttr.array[i*3+2] = arr[base].z + (Math.random()-0.5)*0.1;
      }
    }
    posAttr.needsUpdate = true;
    offAttr.needsUpdate = true;
  }

  // 爱心函数 (参数方程)
  function generateHeart(num=2000, scale=1.0){
    const out = [];
    for(let i=0;i<num;i++){
      const t = Math.random() * Math.PI * 2;
      // heart param eq in 2D
      const x = 16 * Math.pow(Math.sin(t),3);
      const y = 13 * Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t);
      out.push({ x: x * 0.8 * scale, y: y * 0.8 * scale, z: (Math.random()-0.5)*6*scale });
    }
    // center & normalize
    return out;
  }

  // 花朵 (玫瑰极坐标)
  function generateFlower(num=2000, scale=1.0){
    const out = [];
    for(let i=0;i<num;i++){
      const a = Math.random() * Math.PI * 2;
      const r = Math.sin(5*a) * 10 * Math.random() * 0.6 + Math.random()*6;
      const x = r * Math.cos(a);
      const y = r * Math.sin(a);
      out.push({x: x * scale*0.9, y: y * scale*0.9, z: (Math.random()-0.5)*8*scale});
    }
    return out;
  }

  // 五角星 (polygon points)
  function generateStar(num=2000, scale=1.0){
    const out = [];
    // create a 5-point star outline and jitter fill
    for(let i=0;i<num;i++){
      const t = Math.random();
      const angle = Math.random() * Math.PI*2;
      // compute star radius by angle
      const r = 20 * ( (Math.sin(5*angle) > 0) ? 1 : 0.4 ) * (0.6 + Math.random()*0.6);
      const x = Math.cos(angle)*r;
      const y = Math.sin(angle)*r;
      out.push({x: x*scale*0.7, y: y*scale*0.7, z: (Math.random()-0.5)*6*scale});
    }
    return out;
  }

  // '佛像'：预设为莲花 + 可上传模型点云（如果用户上传模型会替换）
  function generateBuddhaLike(num=2000, scale=1.0){
    // approximate lotus + silhouette vertical stack
    const out = [];
    for(let i=0;i<num;i++){
      const layer = Math.random();
      const theta = Math.random()*Math.PI*2;
      const r = (1 - layer) * (10 + layer*12) * (0.2 + Math.random()*0.8);
      const x = Math.cos(theta)*r;
      const y = layer*35 - 10 + (Math.random()-0.5)*6;
      const z = Math.sin(theta)* (6 * layer) + (Math.random()-0.5)*4;
      out.push({x: x*scale*0.6, y: y*scale*0.7, z: z*scale*0.6});
    }
    return out;
  }

  // 烟花：分散的点 + outward velocity (we'll animate by offsets)
  function generateFireworks(num=12000, scale=1.0){
    const out = [];
    for(let i=0;i<num;i++){
      // random direction
      const u = Math.random()*2 - 1;
      const theta = Math.random()*Math.PI*2;
      const r = Math.pow(Math.random(), 0.3) * 40 * (0.3 + Math.random()*1.2);
      const x = Math.sqrt(1 - u*u) * Math.cos(theta) * r;
      const y = Math.sqrt(1 - u*u) * Math.sin(theta) * r;
      const z = u * r * 0.6;
      out.push({x: x*scale, y: y*scale, z: z*scale});
    }
    return out;
  }

  // 默认载入爱心
  setPointCloudFromArray(generateHeart(4000, 1.0));

  // ---------- 手势检测 (MediaPipe Hands) ----------
  let lastHandDistance = null;
  let lastTime = performance.now();
  const hands = new Hands({locateFile: (file) => {
    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
  }});
  hands.setOptions({
    maxNumHands: 2,
    modelComplexity: 1,
    minDetectionConfidence: 0.6,
    minTrackingConfidence: 0.6
  });

  hands.onResults(onHandsResults);

  // Camera capture
  const cameraMp = new Camera(videoEl, {
    onFrame: async () => {
      await hands.send({image: videoEl});
    },
    width: 640,
    height: 480
  });
  await cameraMp.start();

  function getDistanceBetweenPoints(p1, p2){
    const dx = p1.x - p2.x;
    const dy = p1.y - p2.y;
    const dz = (p1.z || 0) - (p2.z || 0);
    return Math.sqrt(dx*dx + dy*dy + dz*dz);
  }

  // We will map the normalized distance to scale/spread
  let targetScale = 1.0;
  let targetSpread = 1.0;

  function onHandsResults(results){
    // results.multiHandLandmarks: array of landmarks for each detected hand
    if(!results.multiHandLandmarks || results.multiHandLandmarks.length === 0){
      // decay back to default
      targetScale = THREE.MathUtils.lerp(targetScale, 1.0, 0.06);
      targetSpread = THREE.MathUtils.lerp(targetSpread, 1.0, 0.06);
      return;
    }

    // find both hands if present and compute average thumb-index distance per hand
    let distances = [];
    for(const hand of results.multiHandLandmarks){
      // landmarks: 4 is thumb tip, 8 is index tip (MediaPipe indices)
      const thumb = hand[4];
      const index = hand[8];
      const d = getDistanceBetweenPoints(thumb, index);
      distances.push(d);
    }

    // If two hands, consider the distance between the two middle points of both hands (for scaling large)
    if(distances.length === 1){
      const d = distances[0];
      // typical normalized MP distances are small (~0.02 - 0.25), map to spread
      // invert: smaller distance -> smaller spread
      const mapped = THREE.MathUtils.clamp((d - 0.02) / 0.2, 0, 1);
      targetSpread = 0.4 + mapped * 2.2; // spread multiplier
      targetScale = 0.6 + mapped * 1.8;
    } else {
      // two hands present: use distance between the centers of the two hands to control big changes
      const h0 = results.multiHandLandmarks[0];
      const h1 = results.multiHandLandmarks[1];
      const c0 = h0[9], c1 = h1[9]; // palm centers
      const centerDist = getDistanceBetweenPoints(c0, c1);
      const mapped = THREE.MathUtils.clamp((centerDist - 0.02) / 0.5, 0, 1);
      targetSpread = 0.6 + mapped * 3.8;
      targetScale = 0.6 + mapped * 2.6;
    }
  }

  // ---------- 动画循环 ----------
  const uTime = particleMat.uniforms.uTime;
  const uScale = particleMat.uniforms.uScale;
  const uSpread = particleMat.uniforms.uSpread;
  const uColor = particleMat.uniforms.uColor;
  const uPointSize = particleMat.uniforms.uPointSize;

  let timeStart = performance.now();

  function animate(){
    requestAnimationFrame(animate);
    const now = performance.now();
    const t = (now - timeStart) / 1000;
    uTime.value = t;

    // Lerp to smooth targetScale/Spread
    uScale.value = THREE.MathUtils.lerp(uScale.value, targetScale, 0.08);
    uSpread.value = THREE.MathUtils.lerp(uSpread.value, targetSpread, 0.08);

    // subtle rotation for dynamic look
    points.rotation.y = Math.sin(t*0.12) * 0.12;
    points.rotation.x = Math.sin(t*0.06) * 0.06;

    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  // ---------- UI Bindings ----------
  colorPicker.addEventListener('input', (e) => {
    const hex = e.target.value;
    uColor.value.set(hex);
    // color attribute base
    const colAttr = particleGeometry.getAttribute('color');
    for(let i=0;i<MAX_PARTICLES;i++){
      const c = new THREE.Color(hex);
      colAttr.array[i*3+0] = c.r;
      colAttr.array[i*3+1] = c.g;
      colAttr.array[i*3+2] = c.b;
    }
    colAttr.needsUpdate = true;
  });

  modelSelect.addEventListener('change', (e)=>{
    const v = e.target.value;
    if(v === 'heart') setPointCloudFromArray(generateHeart(4000, 1.0));
    else if(v === 'flower') setPointCloudFromArray(generateFlower(4000, 1.0));
    else if(v === 'star') setPointCloudFromArray(generateStar(4000, 1.0));
    else if(v === 'buddha') setPointCloudFromArray(generateBuddhaLike(4000, 1.0));
    else if(v === 'fireworks') setPointCloudFromArray(generateFireworks(MAX_PARTICLES, 1.0));
  });

  uploader.addEventListener('change', async (ev)=>{
    const file = ev.target.files[0];
    if(!file) return;
    // try to load supported formats
    const name = file.name.toLowerCase();
    const url = URL.createObjectURL(file);
    try{
      if(name.endsWith('.gltf') || name.endsWith('.glb')){
        const loader = new THREE.GLTFLoader();
        loader.load(url, gltf=>{
          const pts = [];
          gltf.scene.traverse(ch=>{
            if(ch.isMesh){
              const geom = ch.geometry;
              const pos = geom.attributes.position;
              for(let i=0;i<pos.count;i++){
                pts.push({x: pos.getX(i), y: pos.getY(i), z: pos.getZ(i)});
              }
            }
          });
          // normalize
          normalizeAndSet(pts);
          URL.revokeObjectURL(url);
        });
      } else if(name.endsWith('.ply')){
        const loader = new THREE.PLYLoader();
        loader.load(url, ply=>{
          const pos = ply.attributes.position;
          const pts = [];
          for(let i=0;i<pos.count;i++){
            pts.push({x: pos.getX(i), y: pos.getY(i), z: pos.getZ(i)});
          }
          normalizeAndSet(pts);
        });
      } else if(name.endsWith('.obj')){
        // optional: user could add an OBJ loader
        alert('OBJ 文件支持需要额外 loader；请使用 glTF/PLY 或更新代码。');
      } else {
        alert('不支持的模型类型，请上传 glTF(.gltf/.glb) 或 PLY 点云。');
      }
    }catch(err){
      console.error(err);
      alert('加载模型失败：' + err.message);
    }
  });

  function normalizeAndSet(pts){
    if(pts.length === 0) return;
    // center and scale so it fits
    let minx=1e9,miny=1e9,minz=1e9,maxx=-1e9,maxy=-1e9,maxz=-1e9;
    for(const p of pts){
      if(p.x < minx) minx=p.x; if(p.y<miny) miny=p.y; if(p.z<minz) minz=p.z;
      if(p.x > maxx) maxx=p.x; if(p.y>maxy) maxy=p.y; if(p.z>maxz) maxz=p.z;
    }
    const cx = (minx+maxx)/2, cy=(miny+maxy)/2, cz=(minz+maxz)/2;
    const maxRange = Math.max(maxx-minx, maxy-miny, maxz-minz);
    const out = pts.map(p=>({x:(p.x-cx)/(maxRange/1.6), y:(p.y-cy)/(maxRange/1.6), z:(p.z-cz)/(maxRange/1.6)}));
    setPointCloudFromArray(out);
  }

  // 全屏按钮
  fsBtn.addEventListener('click', ()=>{
    if(!document.fullscreenElement){
      container.requestFullscreen().catch(()=>{});
    } else {
      document.exitFullscreen().catch(()=>{});
    }
  });

  // 响应窗口大小
  window.addEventListener('resize', ()=>{
    width = container.clientWidth; height = container.clientHeight;
    camera.aspect = width/height; camera.updateProjectionMatrix();
    renderer.setSize(width, height);
    particleMat.uniforms.uPixelRatio.value = window.devicePixelRatio;
  });

  // ---------- 可选调试 GUI ----------
  const gui = new lil.GUI({ title: '粒子控制', width: 300 });
  const guiParams = {
    pointSize: 6,
    baseSpread: 1.0,
    baseScale: 1.0,
    autoRotate: true
  };
  gui.add(guiParams, 'pointSize', 1, 30, 1).onChange(v=>uPointSize.value = v);
  gui.add(guiParams, 'baseSpread', 0.1, 5, 0.01).onChange(v=> targetSpread = v);
  gui.add(guiParams, 'baseScale', 0.3, 4, 0.01).onChange(v=> targetScale = v);
  gui.add(guiParams, 'autoRotate').onChange(v=> controls.enableRotate = v);

  // initial GUI values
  uPointSize.value = guiParams.pointSize;
  controls.enableRotate = guiParams.autoRotate;

})();
</script>
</body>
</html>
